{"ast":null,"code":"function assertNonEmptyString(str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str);\n  }\n}\n\nfunction assertNumber(number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number);\n  }\n}\n\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emojibase-data@5/en/data.json';\nconst DEFAULT_LOCALE = 'en'; // like lodash's uniqBy but much smaller\n\nfunction uniqBy(arr, func) {\n  const set = new Set();\n  const res = [];\n\n  for (const item of arr) {\n    const key = func(item);\n\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n\n  return res;\n}\n\nfunction uniqEmoji(emojis) {\n  return uniqBy(emojis, _ => _.unicode);\n}\n\nfunction initialMigration(db) {\n  function createObjectStore(name, keyPath, indexes) {\n    const store = keyPath ? db.createObjectStore(name, {\n      keyPath\n    }) : db.createObjectStore(name);\n\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, {\n          multiEntry\n        });\n      }\n    }\n\n    return store;\n  }\n\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI,\n  /* keyPath */\n  FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS,\n    /* multiEntry */\n    true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE,\n    /* multiEntry */\n    true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\n\nconst openReqs = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\n\nfunction handleOpenOrDeleteReq(resolve, reject, req) {\n  req.onerror = () => reject(req.error);\n\n  req.onblocked = () => reject(new Error('IDB blocked'));\n\n  req.onsuccess = () => resolve(req.result);\n}\n\nasync function createDatabase(dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openReqs[dbName] = req;\n\n    req.onupgradeneeded = e => {\n      const db = req.result;\n\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(db);\n      }\n    };\n\n    handleOpenOrDeleteReq(resolve, reject, req);\n  }); // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n\n  db.onclose = () => closeDatabase(dbName);\n\n  return db;\n}\n\nfunction openDatabase(dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n\n  return databaseCache[dbName];\n}\n\nfunction dbPromise(db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(storeName, readOnlyOrReadWrite);\n    const store = typeof storeName === 'string' ? tx.objectStore(storeName) : storeName.map(name => tx.objectStore(name));\n    let res;\n    cb(store, result => {\n      res = result;\n    });\n\n    tx.oncomplete = () => resolve(res);\n\n    tx.onerror = () => reject(tx.error);\n  });\n}\n\nfunction closeDatabase(dbName) {\n  // close any open requests\n  const req = openReqs[dbName];\n  const db = req && req.result;\n\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n\n  delete openReqs[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\n\nfunction deleteDatabase(dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n} // The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\n\n\nfunction addOnCloseListener(dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n\n  listeners.push(listener);\n}\n\nconst MIN_SEARCH_TEXT_LENGTH = 2; // list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emojibase-data/en/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\n\nconst irregularEmoticons = new Set([':D', 'xD', \":'D\", 'o:)', ':x', ':p', ';p', 'xp', ':l', ':z', ':j', '8D', 'xo', '8)', ':B', ':o', ':s', \":'o\", 'Dx', 'x(', 'D:', ':c', '>0)', ':3', '</3', '<3', '\\\\m/', ':E', '8#']);\n\nfunction extractTokens(str) {\n  return str.split(/[\\s_]+/).map(word => {\n    if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n      // for pure emoticons like :) or :-), just leave them as-is\n      return word.toLowerCase();\n    }\n\n    return word.replace(/[)(:,]/g, '').replace(/â€™/g, \"'\").toLowerCase();\n  }).filter(Boolean);\n} // Transform emojibase data for storage in IDB\n\n\nfunction transformEmojiBaseData(emojiBaseData) {\n  const res = emojiBaseData.map(({\n    annotation,\n    emoticon,\n    group,\n    order,\n    shortcodes,\n    skins,\n    tags,\n    emoji,\n    version\n  }) => {\n    const tokens = [...new Set([...shortcodes.map(extractTokens).flat(), ...tags.map(extractTokens).flat(), ...extractTokens(annotation), emoticon].filter(Boolean).map(_ => _.toLowerCase()).filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH))].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      shortcodes,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n\n      for (const {\n        tone,\n        emoji,\n        version\n      } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n\n    return res;\n  });\n  return res;\n} // helper functions that help compress the code better\n\n\nfunction callStore(store, method, key, cb) {\n  store[method](key).onsuccess = e => cb && cb(e.target.result);\n}\n\nfunction getIDB(store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\n\nfunction getAllIDB(store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\n\nfunction getAllKeysIDB(store, key, cb) {\n  callStore(store, 'getAllKeys', key, cb);\n} // like lodash's minBy\n\n\nfunction minBy(array, func) {\n  let minItem = array[0];\n\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n\n  return minItem;\n} // return an array of results representing all items that are found in each one of the arrays\n\n\nfunction findCommonMembers(arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n\n  return results;\n}\n\nasync function isEmpty(db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL));\n}\n\nasync function hasData(db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL].map(key => get(db, STORE_KEYVALUE, key)));\n  return oldETag === eTag && oldUrl === url;\n}\n\nasync function loadData(db, emojiBaseData, url, eTag) {\n  try {\n    const transformedData = transformEmojiBaseData(emojiBaseData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore]) => {\n      let oldETag;\n      let oldUrl;\n      let oldKeys;\n      let todo = 0;\n\n      function checkFetched() {\n        if (++todo === 3) {\n          onFetched();\n        }\n      }\n\n      function onFetched() {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return;\n        } // delete old data\n\n\n        for (const key of oldKeys) {\n          emojiStore.delete(key);\n        } // insert new data\n\n\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n      }\n\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n      getAllKeysIDB(emojiStore, undefined, result => {\n        oldKeys = result;\n        checkFetched();\n      });\n    });\n  } finally {}\n}\n\nasync function getEmojiByGroup(db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  });\n}\n\nasync function getEmojiBySearchQuery(db, query) {\n  const tokens = extractTokens(query);\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1 ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n      : IDBKeyRange.only(token); // treat all other tokens as an exact match\n\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  });\n}\n\nasync function getEmojiByShortcode(db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n  return emojis.filter(_ => {\n    const lowerShortcodes = _.shortcodes.map(_ => _.toLowerCase());\n\n    return lowerShortcodes.includes(shortcode.toLowerCase());\n  })[0] || null;\n}\n\nasync function getEmojiByUnicode(db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, cb) => getIDB(emojiStore, unicode, result => {\n    if (result) {\n      return cb(result);\n    }\n\n    getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n  }));\n}\n\nfunction get(db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, cb) => getIDB(store, key, cb));\n}\n\nfunction set(db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, store => store.put(value, key));\n}\n\nfunction incrementFavoriteEmojiCount(db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, store => {\n    getIDB(store, unicode, result => store.put((result || 0) + 1, unicode));\n  });\n}\n\nfunction getTopFavoriteEmoji(db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return [];\n  }\n\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], cb) => {\n    const results = [];\n\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n\n      if (!cursor) {\n        // no more results\n        return cb(results);\n      }\n\n      function addResult(result) {\n        results.push(result);\n\n        if (results.length === limit) {\n          return cb(results); // done, reached the limit\n        }\n\n        cursor.continue();\n      }\n\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n\n      if (custom) {\n        return addResult(custom);\n      } // TODO: this could be optimized by doing the get and the cursor.continue() in parallel\n\n\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji);\n        } // emoji not found somehow, ignore (may happen if custom emoji change)\n\n\n        cursor.continue();\n      });\n    };\n  });\n} // @rollup/plugin-strip doesn't strip console.logs properly\n\n\nfunction log() {}\n\nfunction warn() {\n  /* istanbul ignore if */\n  {\n    console.warn(...arguments);\n  }\n} // trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie(arr, itemToTokens) {\n  const map = new Map();\n\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n\n    for (const token of tokens) {\n      let currentMap = map;\n\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n\n        currentMap = nextMap;\n      }\n\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n\n      valuesAtCoda.push(item);\n    }\n  }\n\n  const search = (query, exact) => {\n    let currentMap = map;\n\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return [];\n      }\n    }\n\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || [];\n    }\n\n    const results = []; // traverse\n\n    const queue = currentMap ? [currentMap] : [];\n\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) {\n          // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n\n    return results;\n  };\n\n  return search;\n}\n\nconst requiredKeys = ['name', 'shortcodes', 'url'];\n\nfunction assertCustomEmojis(customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray && customEmojis.length && (!customEmojis[0] || requiredKeys.some(key => !(key in customEmojis[0])));\n\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Expected custom emojis to be in correct format');\n  }\n}\n\nfunction customEmojiIndex(customEmojis) {\n  assertCustomEmojis(customEmojis);\n\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1; //\n  // all()\n  //\n\n\n  const all = customEmojis.sort(sortByName); //\n  // search()\n  //\n\n  const emojiToTokens = emoji => [...new Set(emoji.shortcodes.map(shortcode => extractTokens(shortcode)).flat())];\n\n  const searchTrie = trie(customEmojis, emojiToTokens);\n\n  const searchByExactMatch = _ => searchTrie(_, true);\n\n  const searchByPrefix = _ => searchTrie(_, false); // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n\n\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName);\n  }; //\n  // byShortcode, byName\n  //\n\n\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n\n    for (const shortcode of customEmoji.shortcodes) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  };\n} // remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\n\n\nfunction cleanEmoji(emoji) {\n  if (!emoji) {\n    return emoji;\n  }\n\n  delete emoji.tokens;\n\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n\n  return emoji;\n}\n\nfunction warnETag(eTag) {\n  if (!eTag) {\n    warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\n\nconst requiredKeys$1 = ['annotation', 'emoji', 'emoticon', 'group', 'order', 'shortcodes', 'tags', 'version'];\n\nfunction assertEmojiBaseData(emojiBaseData) {\n  if (!emojiBaseData || !Array.isArray(emojiBaseData) || !emojiBaseData[0] || typeof emojiBaseData[0] !== 'object' || requiredKeys$1.some(key => !(key in emojiBaseData[0]))) {\n    throw new Error('Expected emojibase full (not compact) data, but data is in wrong format');\n  }\n}\n\nfunction assertStatus(response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status);\n  }\n}\n\nasync function getETag(dataSource) {\n  const response = await fetch(dataSource, {\n    method: 'HEAD'\n  });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag;\n}\n\nasync function getETagAndData(dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiBaseData = await response.json();\n  assertEmojiBaseData(emojiBaseData);\n  return [eTag, emojiBaseData];\n} // TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\n\n\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  var i = -1;\n\n  while (++i < length) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n\n  return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\n\n\nfunction binaryStringToArrayBuffer(binary) {\n  var length = binary.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  var i = -1;\n\n  while (++i < length) {\n    arr[i] = binary.charCodeAt(i);\n  }\n\n  return buf;\n} // generate a checksum based on the stringified JSON\n\n\nasync function jsonChecksum(object) {\n  const inString = JSON.stringify(object);\n  const inBuffer = binaryStringToArrayBuffer(inString); // this does not need to be cryptographically secure, SHA-1 is fine\n\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res;\n}\n\nasync function checkForUpdates(db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiBaseData;\n  let eTag = await getETag(dataSource);\n\n  if (!eTag) {\n    // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiBaseData = eTagAndData[1];\n\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiBaseData);\n    }\n  }\n\n  if (await hasData(db, dataSource, eTag)) ;else {\n    if (!emojiBaseData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiBaseData = eTagAndData[1];\n    }\n\n    await loadData(db, emojiBaseData, dataSource, eTag);\n  }\n}\n\nasync function loadDataForFirstTime(db, dataSource) {\n  let [eTag, emojiBaseData] = await getETagAndData(dataSource);\n\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiBaseData);\n  }\n\n  await loadData(db, emojiBaseData, dataSource, eTag);\n}\n\nclass Database {\n  constructor({\n    dataSource = DEFAULT_DATA_SOURCE,\n    locale = DEFAULT_LOCALE,\n    customEmoji = []\n  } = {}) {\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = `emoji-picker-element-${this.locale}`;\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n\n  async _init() {\n    const db = this._db = await openDatabase(this._dbName);\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else {\n      // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n\n  async ready() {\n    if (!this._ready) {\n      this._ready = this._init();\n    }\n\n    return this._ready;\n  }\n\n  async getEmojiByGroup(group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji);\n  }\n\n  async getEmojiBySearchQuery(query) {\n    assertNonEmptyString(query);\n    await this.ready();\n\n    const customs = this._custom.search(query);\n\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [...customs, ...natives];\n  }\n\n  async getEmojiByShortcode(shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n\n    const custom = this._custom.byShortcode(shortcode);\n\n    if (custom) {\n      return custom;\n    }\n\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode));\n  }\n\n  async getEmojiByUnicodeOrName(unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n\n    const custom = this._custom.byName(unicodeOrName);\n\n    if (custom) {\n      return custom;\n    }\n\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName));\n  }\n\n  async getPreferredSkinTone() {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0;\n  }\n\n  async setPreferredSkinTone(skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone);\n  }\n\n  async incrementFavoriteEmojiCount(unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName);\n  }\n\n  async getTopFavoriteEmoji(limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji);\n  }\n\n  set customEmoji(customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n\n  get customEmoji() {\n    return this._custom.all;\n  }\n\n  async _shutdown() {\n    await this.ready(); // reopen if we've already been closed/deleted\n\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) {\n      /* ignore network errors (offline-first) */\n    }\n\n    if (this._db) {\n      return true; // we need to actually run the close/delete logic, so we return true\n    }\n  } // clear references to IDB, e.g. during a close event\n\n\n  _clear() {\n    log('_clear database', this._dbName); // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n\n  async close() {\n    if (await this._shutdown()) {\n      await closeDatabase(this._dbName);\n    }\n  }\n\n  async delete() {\n    if (await this._shutdown()) {\n      await deleteDatabase(this._dbName);\n    }\n  }\n\n}\n\nexport default Database;","map":{"version":3,"sources":["/home/joaquim/internship/superchat/node_modules/emoji-picker-element/database.js"],"names":["assertNonEmptyString","str","Error","assertNumber","number","DB_VERSION_CURRENT","DB_VERSION_INITIAL","STORE_EMOJI","STORE_KEYVALUE","STORE_FAVORITES","FIELD_TOKENS","INDEX_TOKENS","FIELD_UNICODE","INDEX_COUNT","FIELD_GROUP","FIELD_ORDER","INDEX_GROUP_AND_ORDER","KEY_ETAG","KEY_URL","KEY_PREFERRED_SKINTONE","MODE_READONLY","MODE_READWRITE","INDEX_SKIN_UNICODE","FIELD_SKIN_UNICODE","DEFAULT_DATA_SOURCE","DEFAULT_LOCALE","uniqBy","arr","func","set","Set","res","item","key","has","add","push","uniqEmoji","emojis","_","unicode","initialMigration","db","createObjectStore","name","keyPath","indexes","store","indexName","multiEntry","Object","entries","createIndex","undefined","openReqs","databaseCache","onCloseListeners","handleOpenOrDeleteReq","resolve","reject","req","onerror","error","onblocked","onsuccess","result","createDatabase","dbName","Promise","indexedDB","open","onupgradeneeded","e","oldVersion","onclose","closeDatabase","openDatabase","dbPromise","storeName","readOnlyOrReadWrite","cb","tx","transaction","objectStore","map","oncomplete","close","listeners","listener","deleteDatabase","addOnCloseListener","MIN_SEARCH_TEXT_LENGTH","irregularEmoticons","extractTokens","split","word","match","toLowerCase","replace","filter","Boolean","transformEmojiBaseData","emojiBaseData","annotation","emoticon","group","order","shortcodes","skins","tags","emoji","version","tokens","flat","length","sort","skinTones","skinUnicodes","skinVersions","tone","callStore","method","target","getIDB","getAllIDB","getAllKeysIDB","minBy","array","minItem","i","findCommonMembers","arrays","uniqByFunc","shortestArray","results","some","findIndex","isEmpty","get","hasData","url","eTag","oldETag","oldUrl","all","loadData","transformedData","emojiStore","metaStore","oldKeys","todo","checkFetched","onFetched","delete","data","put","getEmojiByGroup","range","IDBKeyRange","bound","index","getEmojiBySearchQuery","query","intermediateResults","checkDone","onDone","a","b","token","only","getEmojiByShortcode","shortcode","lowerShortcodes","includes","getEmojiByUnicode","value","incrementFavoriteEmojiCount","getTopFavoriteEmoji","customEmojiIndex","limit","favoritesStore","openCursor","cursor","addResult","continue","unicodeOrName","primaryKey","custom","byName","log","warn","console","arguments","CODA_MARKER","trie","itemToTokens","Map","currentMap","char","charAt","nextMap","valuesAtCoda","search","exact","queue","shift","entriesSortedByKey","requiredKeys","assertCustomEmojis","customEmojis","isArray","Array","firstItemIsFaulty","sortByName","emojiToTokens","searchTrie","searchByExactMatch","searchByPrefix","shortcodeToEmoji","nameToEmoji","customEmoji","byShortcode","cleanEmoji","len","warnETag","requiredKeys$1","assertEmojiBaseData","assertStatus","response","dataSource","Math","floor","status","getETag","fetch","headers","getETagAndData","json","arrayBufferToBinaryString","buffer","binary","bytes","Uint8Array","byteLength","String","fromCharCode","binaryStringToArrayBuffer","buf","ArrayBuffer","charCodeAt","jsonChecksum","object","inString","JSON","stringify","inBuffer","outBuffer","crypto","subtle","digest","outBinString","btoa","checkForUpdates","eTagAndData","loadDataForFirstTime","Database","constructor","locale","_dbName","_db","_lazyUpdate","_custom","_clear","bind","_ready","_init","empty","ready","customs","natives","getEmojiByUnicodeOrName","getPreferredSkinTone","setPreferredSkinTone","skinTone","_shutdown","err"],"mappings":"AAAA,SAASA,oBAAT,CAA+BC,GAA/B,EAAoC;AAClC,MAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B,CAACA,GAAhC,EAAqC;AACnC,UAAM,IAAIC,KAAJ,CAAU,uCAAuCD,GAAjD,CAAN;AACD;AACF;;AAED,SAASE,YAAT,CAAuBC,MAAvB,EAA+B;AAC7B,MAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UAAM,IAAIF,KAAJ,CAAU,6BAA6BE,MAAvC,CAAN;AACD;AACF;;AAED,MAAMC,kBAAkB,GAAG,CAA3B;AACA,MAAMC,kBAAkB,GAAG,CAA3B;AACA,MAAMC,WAAW,GAAG,OAApB;AACA,MAAMC,cAAc,GAAG,UAAvB;AACA,MAAMC,eAAe,GAAG,WAAxB;AACA,MAAMC,YAAY,GAAG,QAArB;AACA,MAAMC,YAAY,GAAG,QAArB;AACA,MAAMC,aAAa,GAAG,SAAtB;AACA,MAAMC,WAAW,GAAG,OAApB;AACA,MAAMC,WAAW,GAAG,OAApB;AACA,MAAMC,WAAW,GAAG,OAApB;AACA,MAAMC,qBAAqB,GAAG,aAA9B;AACA,MAAMC,QAAQ,GAAG,MAAjB;AACA,MAAMC,OAAO,GAAG,KAAhB;AACA,MAAMC,sBAAsB,GAAG,UAA/B;AACA,MAAMC,aAAa,GAAG,UAAtB;AACA,MAAMC,cAAc,GAAG,WAAvB;AACA,MAAMC,kBAAkB,GAAG,cAA3B;AACA,MAAMC,kBAAkB,GAAG,cAA3B;AAEA,MAAMC,mBAAmB,GAAG,4DAA5B;AACA,MAAMC,cAAc,GAAG,IAAvB,C,CAEA;;AACA,SAASC,MAAT,CAAiBC,GAAjB,EAAsBC,IAAtB,EAA4B;AAC1B,QAAMC,GAAG,GAAG,IAAIC,GAAJ,EAAZ;AACA,QAAMC,GAAG,GAAG,EAAZ;;AACA,OAAK,MAAMC,IAAX,IAAmBL,GAAnB,EAAwB;AACtB,UAAMM,GAAG,GAAGL,IAAI,CAACI,IAAD,CAAhB;;AACA,QAAI,CAACH,GAAG,CAACK,GAAJ,CAAQD,GAAR,CAAL,EAAmB;AACjBJ,MAAAA,GAAG,CAACM,GAAJ,CAAQF,GAAR;AACAF,MAAAA,GAAG,CAACK,IAAJ,CAASJ,IAAT;AACD;AACF;;AACD,SAAOD,GAAP;AACD;;AAED,SAASM,SAAT,CAAoBC,MAApB,EAA4B;AAC1B,SAAOZ,MAAM,CAACY,MAAD,EAASC,CAAC,IAAIA,CAAC,CAACC,OAAhB,CAAb;AACD;;AAED,SAASC,gBAAT,CAA2BC,EAA3B,EAA+B;AAC7B,WAASC,iBAAT,CAA4BC,IAA5B,EAAkCC,OAAlC,EAA2CC,OAA3C,EAAoD;AAClD,UAAMC,KAAK,GAAGF,OAAO,GACjBH,EAAE,CAACC,iBAAH,CAAqBC,IAArB,EAA2B;AAAEC,MAAAA;AAAF,KAA3B,CADiB,GAEjBH,EAAE,CAACC,iBAAH,CAAqBC,IAArB,CAFJ;;AAGA,QAAIE,OAAJ,EAAa;AACX,WAAK,MAAM,CAACE,SAAD,EAAY,CAACH,OAAD,EAAUI,UAAV,CAAZ,CAAX,IAAiDC,MAAM,CAACC,OAAP,CAAeL,OAAf,CAAjD,EAA0E;AACxEC,QAAAA,KAAK,CAACK,WAAN,CAAkBJ,SAAlB,EAA6BH,OAA7B,EAAsC;AAAEI,UAAAA;AAAF,SAAtC;AACD;AACF;;AACD,WAAOF,KAAP;AACD;;AAEDJ,EAAAA,iBAAiB,CAACnC,cAAD,CAAjB;AACAmC,EAAAA,iBAAiB,CAACpC,WAAD;AAAc;AAAcK,EAAAA,aAA5B,EAA2C;AAC1D,KAACD,YAAD,GAAgB,CAACD,YAAD;AAAe;AAAiB,QAAhC,CAD0C;AAE1D,KAACM,qBAAD,GAAyB,CAAC,CAACF,WAAD,EAAcC,WAAd,CAAD,CAFiC;AAG1D,KAACO,kBAAD,GAAsB,CAACC,kBAAD;AAAqB;AAAiB,QAAtC;AAHoC,GAA3C,CAAjB;AAKAoB,EAAAA,iBAAiB,CAAClC,eAAD,EAAkB4C,SAAlB,EAA6B;AAC5C,KAACxC,WAAD,GAAe,CAAC,EAAD;AAD6B,GAA7B,CAAjB;AAGD;;AAED,MAAMyC,QAAQ,GAAG,EAAjB;AACA,MAAMC,aAAa,GAAG,EAAtB;AACA,MAAMC,gBAAgB,GAAG,EAAzB;;AAEA,SAASC,qBAAT,CAAgCC,OAAhC,EAAyCC,MAAzC,EAAiDC,GAAjD,EAAsD;AACpDA,EAAAA,GAAG,CAACC,OAAJ,GAAc,MAAMF,MAAM,CAACC,GAAG,CAACE,KAAL,CAA1B;;AACAF,EAAAA,GAAG,CAACG,SAAJ,GAAgB,MAAMJ,MAAM,CAAC,IAAIzD,KAAJ,CAAU,aAAV,CAAD,CAA5B;;AACA0D,EAAAA,GAAG,CAACI,SAAJ,GAAgB,MAAMN,OAAO,CAACE,GAAG,CAACK,MAAL,CAA7B;AACD;;AAED,eAAeC,cAAf,CAA+BC,MAA/B,EAAuC;AACrC,QAAMzB,EAAE,GAAG,MAAM,IAAI0B,OAAJ,CAAY,CAACV,OAAD,EAAUC,MAAV,KAAqB;AAChD,UAAMC,GAAG,GAAGS,SAAS,CAACC,IAAV,CAAeH,MAAf,EAAuB9D,kBAAvB,CAAZ;AACAiD,IAAAA,QAAQ,CAACa,MAAD,CAAR,GAAmBP,GAAnB;;AACAA,IAAAA,GAAG,CAACW,eAAJ,GAAsBC,CAAC,IAAI;AACzB,YAAM9B,EAAE,GAAGkB,GAAG,CAACK,MAAf;;AAEA,UAAIO,CAAC,CAACC,UAAF,GAAenE,kBAAnB,EAAuC;AACrCmC,QAAAA,gBAAgB,CAACC,EAAD,CAAhB;AACD;AACF,KAND;;AAOAe,IAAAA,qBAAqB,CAACC,OAAD,EAAUC,MAAV,EAAkBC,GAAlB,CAArB;AACD,GAXgB,CAAjB,CADqC,CAarC;AACA;AACA;;AACAlB,EAAAA,EAAE,CAACgC,OAAH,GAAa,MAAMC,aAAa,CAACR,MAAD,CAAhC;;AACA,SAAOzB,EAAP;AACD;;AAED,SAASkC,YAAT,CAAuBT,MAAvB,EAA+B;AAC7B,MAAI,CAACZ,aAAa,CAACY,MAAD,CAAlB,EAA4B;AAC1BZ,IAAAA,aAAa,CAACY,MAAD,CAAb,GAAwBD,cAAc,CAACC,MAAD,CAAtC;AACD;;AACD,SAAOZ,aAAa,CAACY,MAAD,CAApB;AACD;;AAED,SAASU,SAAT,CAAoBnC,EAApB,EAAwBoC,SAAxB,EAAmCC,mBAAnC,EAAwDC,EAAxD,EAA4D;AAC1D,SAAO,IAAIZ,OAAJ,CAAY,CAACV,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAMsB,EAAE,GAAGvC,EAAE,CAACwC,WAAH,CAAeJ,SAAf,EAA0BC,mBAA1B,CAAX;AACA,UAAMhC,KAAK,GAAG,OAAO+B,SAAP,KAAqB,QAArB,GACVG,EAAE,CAACE,WAAH,CAAeL,SAAf,CADU,GAEVA,SAAS,CAACM,GAAV,CAAcxC,IAAI,IAAIqC,EAAE,CAACE,WAAH,CAAevC,IAAf,CAAtB,CAFJ;AAGA,QAAIb,GAAJ;AACAiD,IAAAA,EAAE,CAACjC,KAAD,EAASkB,MAAD,IAAY;AACpBlC,MAAAA,GAAG,GAAGkC,MAAN;AACD,KAFC,CAAF;;AAIAgB,IAAAA,EAAE,CAACI,UAAH,GAAgB,MAAM3B,OAAO,CAAC3B,GAAD,CAA7B;;AACAkD,IAAAA,EAAE,CAACpB,OAAH,GAAa,MAAMF,MAAM,CAACsB,EAAE,CAACnB,KAAJ,CAAzB;AACD,GAZM,CAAP;AAaD;;AAED,SAASa,aAAT,CAAwBR,MAAxB,EAAgC;AAC9B;AACA,QAAMP,GAAG,GAAGN,QAAQ,CAACa,MAAD,CAApB;AACA,QAAMzB,EAAE,GAAGkB,GAAG,IAAIA,GAAG,CAACK,MAAtB;;AACA,MAAIvB,EAAJ,EAAQ;AACNA,IAAAA,EAAE,CAAC4C,KAAH;AACA,UAAMC,SAAS,GAAG/B,gBAAgB,CAACW,MAAD,CAAlC;;AACA,QAAIoB,SAAJ,EAAe;AACb,WAAK,MAAMC,QAAX,IAAuBD,SAAvB,EAAkC;AAChCC,QAAAA,QAAQ;AACT;AACF;AACF;;AACD,SAAOlC,QAAQ,CAACa,MAAD,CAAf;AACA,SAAOZ,aAAa,CAACY,MAAD,CAApB;AACA,SAAOX,gBAAgB,CAACW,MAAD,CAAvB;AACD;;AAED,SAASsB,cAAT,CAAyBtB,MAAzB,EAAiC;AAC/B,SAAO,IAAIC,OAAJ,CAAY,CAACV,OAAD,EAAUC,MAAV,KAAqB;AACtC;AACAgB,IAAAA,aAAa,CAACR,MAAD,CAAb;AACA,UAAMP,GAAG,GAAGS,SAAS,CAACoB,cAAV,CAAyBtB,MAAzB,CAAZ;AACAV,IAAAA,qBAAqB,CAACC,OAAD,EAAUC,MAAV,EAAkBC,GAAlB,CAArB;AACD,GALM,CAAP;AAMD,C,CAED;AACA;AACA;;;AACA,SAAS8B,kBAAT,CAA6BvB,MAA7B,EAAqCqB,QAArC,EAA+C;AAC7C,MAAID,SAAS,GAAG/B,gBAAgB,CAACW,MAAD,CAAhC;;AACA,MAAI,CAACoB,SAAL,EAAgB;AACdA,IAAAA,SAAS,GAAG/B,gBAAgB,CAACW,MAAD,CAAhB,GAA2B,EAAvC;AACD;;AACDoB,EAAAA,SAAS,CAACnD,IAAV,CAAeoD,QAAf;AACD;;AAED,MAAMG,sBAAsB,GAAG,CAA/B,C,CAEA;AACA;AACA;;AACA,MAAMC,kBAAkB,GAAG,IAAI9D,GAAJ,CAAQ,CACjC,IADiC,EAC3B,IAD2B,EACrB,KADqB,EACd,KADc,EAEjC,IAFiC,EAE3B,IAF2B,EAErB,IAFqB,EAEf,IAFe,EAGjC,IAHiC,EAG3B,IAH2B,EAGrB,IAHqB,EAGf,IAHe,EAIjC,IAJiC,EAI3B,IAJ2B,EAIrB,IAJqB,EAIf,IAJe,EAKjC,IALiC,EAK3B,KAL2B,EAKpB,IALoB,EAKd,IALc,EAMjC,IANiC,EAM3B,IAN2B,EAMrB,KANqB,EAMd,IANc,EAOjC,KAPiC,EAO1B,IAP0B,EAOpB,MAPoB,EAOZ,IAPY,EAQjC,IARiC,CAAR,CAA3B;;AAWA,SAAS+D,aAAT,CAAwB5F,GAAxB,EAA6B;AAC3B,SAAOA,GAAG,CACP6F,KADI,CACE,QADF,EAEJV,GAFI,CAEAW,IAAI,IAAI;AACX,QAAI,CAACA,IAAI,CAACC,KAAL,CAAW,IAAX,CAAD,IAAqBJ,kBAAkB,CAAC1D,GAAnB,CAAuB6D,IAAvB,CAAzB,EAAuD;AACrD;AACA,aAAOA,IAAI,CAACE,WAAL,EAAP;AACD;;AAED,WAAOF,IAAI,CACRG,OADI,CACI,SADJ,EACe,EADf,EAEJA,OAFI,CAEI,IAFJ,EAEU,GAFV,EAGJD,WAHI,EAAP;AAID,GAZI,EAYFE,MAZE,CAYKC,OAZL,CAAP;AAaD,C,CAED;;;AACA,SAASC,sBAAT,CAAiCC,aAAjC,EAAgD;AAC9C,QAAMvE,GAAG,GAAGuE,aAAa,CAAClB,GAAd,CAAkB,CAAC;AAAEmB,IAAAA,UAAF;AAAcC,IAAAA,QAAd;AAAwBC,IAAAA,KAAxB;AAA+BC,IAAAA,KAA/B;AAAsCC,IAAAA,UAAtC;AAAkDC,IAAAA,KAAlD;AAAyDC,IAAAA,IAAzD;AAA+DC,IAAAA,KAA/D;AAAsEC,IAAAA;AAAtE,GAAD,KAAqF;AACjH,UAAMC,MAAM,GAAG,CAAC,GAAG,IAAIlF,GAAJ,CACjB,CACE,GAAG6E,UAAU,CAACvB,GAAX,CAAeS,aAAf,EAA8BoB,IAA9B,EADL,EAEE,GAAGJ,IAAI,CAACzB,GAAL,CAASS,aAAT,EAAwBoB,IAAxB,EAFL,EAGE,GAAGpB,aAAa,CAACU,UAAD,CAHlB,EAIEC,QAJF,EAMGL,MANH,CAMUC,OANV,EAOGhB,GAPH,CAOO7C,CAAC,IAAIA,CAAC,CAAC0D,WAAF,EAPZ,EAQGE,MARH,CAQU5D,CAAC,IAAIA,CAAC,CAAC2E,MAAF,IAAYvB,sBAR3B,CADiB,CAAJ,EAUZwB,IAVY,EAAf;AAWA,UAAMpF,GAAG,GAAG;AACVwE,MAAAA,UADU;AAEVE,MAAAA,KAFU;AAGVC,MAAAA,KAHU;AAIVC,MAAAA,UAJU;AAKVE,MAAAA,IALU;AAMVG,MAAAA,MANU;AAOVxE,MAAAA,OAAO,EAAEsE,KAPC;AAQVC,MAAAA;AARU,KAAZ;;AAUA,QAAIP,QAAJ,EAAc;AACZzE,MAAAA,GAAG,CAACyE,QAAJ,GAAeA,QAAf;AACD;;AACD,QAAII,KAAJ,EAAW;AACT7E,MAAAA,GAAG,CAACqF,SAAJ,GAAgB,EAAhB;AACArF,MAAAA,GAAG,CAACsF,YAAJ,GAAmB,EAAnB;AACAtF,MAAAA,GAAG,CAACuF,YAAJ,GAAmB,EAAnB;;AACA,WAAK,MAAM;AAAEC,QAAAA,IAAF;AAAQT,QAAAA,KAAR;AAAeC,QAAAA;AAAf,OAAX,IAAuCH,KAAvC,EAA8C;AAC5C7E,QAAAA,GAAG,CAACqF,SAAJ,CAAchF,IAAd,CAAmBmF,IAAnB;AACAxF,QAAAA,GAAG,CAACsF,YAAJ,CAAiBjF,IAAjB,CAAsB0E,KAAtB;AACA/E,QAAAA,GAAG,CAACuF,YAAJ,CAAiBlF,IAAjB,CAAsB2E,OAAtB;AACD;AACF;;AACD,WAAOhF,GAAP;AACD,GApCW,CAAZ;AAqCA,SAAOA,GAAP;AACD,C,CAED;;;AAEA,SAASyF,SAAT,CAAoBzE,KAApB,EAA2B0E,MAA3B,EAAmCxF,GAAnC,EAAwC+C,EAAxC,EAA4C;AAC1CjC,EAAAA,KAAK,CAAC0E,MAAD,CAAL,CAAcxF,GAAd,EAAmB+B,SAAnB,GAA+BQ,CAAC,IAAKQ,EAAE,IAAIA,EAAE,CAACR,CAAC,CAACkD,MAAF,CAASzD,MAAV,CAA7C;AACD;;AAED,SAAS0D,MAAT,CAAiB5E,KAAjB,EAAwBd,GAAxB,EAA6B+C,EAA7B,EAAiC;AAC/BwC,EAAAA,SAAS,CAACzE,KAAD,EAAQ,KAAR,EAAed,GAAf,EAAoB+C,EAApB,CAAT;AACD;;AAED,SAAS4C,SAAT,CAAoB7E,KAApB,EAA2Bd,GAA3B,EAAgC+C,EAAhC,EAAoC;AAClCwC,EAAAA,SAAS,CAACzE,KAAD,EAAQ,QAAR,EAAkBd,GAAlB,EAAuB+C,EAAvB,CAAT;AACD;;AAED,SAAS6C,aAAT,CAAwB9E,KAAxB,EAA+Bd,GAA/B,EAAoC+C,EAApC,EAAwC;AACtCwC,EAAAA,SAAS,CAACzE,KAAD,EAAQ,YAAR,EAAsBd,GAAtB,EAA2B+C,EAA3B,CAAT;AACD,C,CAED;;;AACA,SAAS8C,KAAT,CAAgBC,KAAhB,EAAuBnG,IAAvB,EAA6B;AAC3B,MAAIoG,OAAO,GAAGD,KAAK,CAAC,CAAD,CAAnB;;AACA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACb,MAA1B,EAAkCe,CAAC,EAAnC,EAAuC;AACrC,UAAMjG,IAAI,GAAG+F,KAAK,CAACE,CAAD,CAAlB;;AACA,QAAIrG,IAAI,CAACoG,OAAD,CAAJ,GAAgBpG,IAAI,CAACI,IAAD,CAAxB,EAAgC;AAC9BgG,MAAAA,OAAO,GAAGhG,IAAV;AACD;AACF;;AACD,SAAOgG,OAAP;AACD,C,CAED;;;AAEA,SAASE,iBAAT,CAA4BC,MAA5B,EAAoCC,UAApC,EAAgD;AAC9C,QAAMC,aAAa,GAAGP,KAAK,CAACK,MAAD,EAAS5F,CAAC,IAAIA,CAAC,CAAC2E,MAAhB,CAA3B;AACA,QAAMoB,OAAO,GAAG,EAAhB;;AACA,OAAK,MAAMtG,IAAX,IAAmBqG,aAAnB,EAAkC;AAChC;AACA,QAAI,CAACF,MAAM,CAACI,IAAP,CAAYR,KAAK,IAAIA,KAAK,CAACS,SAAN,CAAgBjG,CAAC,IAAI6F,UAAU,CAAC7F,CAAD,CAAV,KAAkB6F,UAAU,CAACpG,IAAD,CAAjD,MAA6D,CAAC,CAAnF,CAAL,EAA4F;AAC1FsG,MAAAA,OAAO,CAAClG,IAAR,CAAaJ,IAAb;AACD;AACF;;AACD,SAAOsG,OAAP;AACD;;AAED,eAAeG,OAAf,CAAwB/F,EAAxB,EAA4B;AAC1B,SAAO,EAAE,MAAMgG,GAAG,CAAChG,EAAD,EAAKlC,cAAL,EAAqBU,OAArB,CAAX,CAAP;AACD;;AAED,eAAeyH,OAAf,CAAwBjG,EAAxB,EAA4BkG,GAA5B,EAAiCC,IAAjC,EAAuC;AACrC,QAAM,CAACC,OAAD,EAAUC,MAAV,IAAoB,MAAM3E,OAAO,CAAC4E,GAAR,CAAY,CAAC/H,QAAD,EAAWC,OAAX,EACzCkE,GADyC,CACrCnD,GAAG,IAAIyG,GAAG,CAAChG,EAAD,EAAKlC,cAAL,EAAqByB,GAArB,CAD2B,CAAZ,CAAhC;AAEA,SAAQ6G,OAAO,KAAKD,IAAZ,IAAoBE,MAAM,KAAKH,GAAvC;AACD;;AAED,eAAeK,QAAf,CAAyBvG,EAAzB,EAA6B4D,aAA7B,EAA4CsC,GAA5C,EAAiDC,IAAjD,EAAuD;AACrD,MAAI;AACF,UAAMK,eAAe,GAAG7C,sBAAsB,CAACC,aAAD,CAA9C;AACA,UAAMzB,SAAS,CAACnC,EAAD,EAAK,CAACnC,WAAD,EAAcC,cAAd,CAAL,EAAoCa,cAApC,EAAoD,CAAC,CAAC8H,UAAD,EAAaC,SAAb,CAAD,KAA6B;AAC9F,UAAIN,OAAJ;AACA,UAAIC,MAAJ;AACA,UAAIM,OAAJ;AACA,UAAIC,IAAI,GAAG,CAAX;;AAEA,eAASC,YAAT,GAAyB;AACvB,YAAI,EAAED,IAAF,KAAW,CAAf,EAAkB;AAChBE,UAAAA,SAAS;AACV;AACF;;AAED,eAASA,SAAT,GAAsB;AACpB,YAAIV,OAAO,KAAKD,IAAZ,IAAoBE,MAAM,KAAKH,GAAnC,EAAwC;AACtC;AACA;AACD,SAJmB,CAKpB;;;AACA,aAAK,MAAM3G,GAAX,IAAkBoH,OAAlB,EAA2B;AACzBF,UAAAA,UAAU,CAACM,MAAX,CAAkBxH,GAAlB;AACD,SARmB,CASpB;;;AACA,aAAK,MAAMyH,IAAX,IAAmBR,eAAnB,EAAoC;AAClCC,UAAAA,UAAU,CAACQ,GAAX,CAAeD,IAAf;AACD;;AACDN,QAAAA,SAAS,CAACO,GAAV,CAAcd,IAAd,EAAoB5H,QAApB;AACAmI,QAAAA,SAAS,CAACO,GAAV,CAAcf,GAAd,EAAmB1H,OAAnB;AACD;;AAEDyG,MAAAA,MAAM,CAACyB,SAAD,EAAYnI,QAAZ,EAAsBgD,MAAM,IAAI;AACpC6E,QAAAA,OAAO,GAAG7E,MAAV;AACAsF,QAAAA,YAAY;AACb,OAHK,CAAN;AAKA5B,MAAAA,MAAM,CAACyB,SAAD,EAAYlI,OAAZ,EAAqB+C,MAAM,IAAI;AACnC8E,QAAAA,MAAM,GAAG9E,MAAT;AACAsF,QAAAA,YAAY;AACb,OAHK,CAAN;AAKA1B,MAAAA,aAAa,CAACsB,UAAD,EAAa9F,SAAb,EAAwBY,MAAM,IAAI;AAC7CoF,QAAAA,OAAO,GAAGpF,MAAV;AACAsF,QAAAA,YAAY;AACb,OAHY,CAAb;AAID,KA3Cc,CAAf;AA4CD,GA9CD,SA8CU,CACT;AACF;;AAED,eAAeK,eAAf,CAAgClH,EAAhC,EAAoC+D,KAApC,EAA2C;AACzC,SAAO5B,SAAS,CAACnC,EAAD,EAAKnC,WAAL,EAAkBa,aAAlB,EAAiC,CAAC+H,UAAD,EAAanE,EAAb,KAAoB;AACnE,UAAM6E,KAAK,GAAGC,WAAW,CAACC,KAAZ,CAAkB,CAACtD,KAAD,EAAQ,CAAR,CAAlB,EAA8B,CAACA,KAAK,GAAG,CAAT,EAAY,CAAZ,CAA9B,EAA8C,KAA9C,EAAqD,IAArD,CAAd;AACAmB,IAAAA,SAAS,CAACuB,UAAU,CAACa,KAAX,CAAiBhJ,qBAAjB,CAAD,EAA0C6I,KAA1C,EAAiD7E,EAAjD,CAAT;AACD,GAHe,CAAhB;AAID;;AAED,eAAeiF,qBAAf,CAAsCvH,EAAtC,EAA0CwH,KAA1C,EAAiD;AAC/C,QAAMlD,MAAM,GAAGnB,aAAa,CAACqE,KAAD,CAA5B;AACA,SAAOrF,SAAS,CAACnC,EAAD,EAAKnC,WAAL,EAAkBa,aAAlB,EAAiC,CAAC+H,UAAD,EAAanE,EAAb,KAAoB;AACnE;AACA,UAAMmF,mBAAmB,GAAG,EAA5B;;AAEA,UAAMC,SAAS,GAAG,MAAM;AACtB,UAAID,mBAAmB,CAACjD,MAApB,KAA+BF,MAAM,CAACE,MAA1C,EAAkD;AAChDmD,QAAAA,MAAM;AACP;AACF,KAJD;;AAMA,UAAMA,MAAM,GAAG,MAAM;AACnB,YAAM/B,OAAO,GAAGJ,iBAAiB,CAACiC,mBAAD,EAAsB5H,CAAC,IAAIA,CAAC,CAACC,OAA7B,CAAjC;AACAwC,MAAAA,EAAE,CAACsD,OAAO,CAACnB,IAAR,CAAa,CAACmD,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAAC5D,KAAF,GAAU6D,CAAC,CAAC7D,KAAZ,GAAoB,CAAC,CAArB,GAAyB,CAAhD,CAAD,CAAF;AACD,KAHD;;AAKA,SAAK,IAAIuB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjB,MAAM,CAACE,MAA3B,EAAmCe,CAAC,EAApC,EAAwC;AACtC,YAAMuC,KAAK,GAAGxD,MAAM,CAACiB,CAAD,CAApB;AACA,YAAM4B,KAAK,GAAG5B,CAAC,KAAKjB,MAAM,CAACE,MAAP,GAAgB,CAAtB,GACV4C,WAAW,CAACC,KAAZ,CAAkBS,KAAlB,EAAyBA,KAAK,GAAG,QAAjC,EAA2C,KAA3C,EAAkD,IAAlD,CADU,CAC8C;AAD9C,QAEVV,WAAW,CAACW,IAAZ,CAAiBD,KAAjB,CAFJ,CAFsC,CAIT;;AAC7B5C,MAAAA,SAAS,CAACuB,UAAU,CAACa,KAAX,CAAiBrJ,YAAjB,CAAD,EAAiCkJ,KAAjC,EAAwC5F,MAAM,IAAI;AACzDkG,QAAAA,mBAAmB,CAAC/H,IAApB,CAAyB6B,MAAzB;AACAmG,QAAAA,SAAS;AACV,OAHQ,CAAT;AAID;AACF,GAzBe,CAAhB;AA0BD;;AAED,eAAeM,mBAAf,CAAoChI,EAApC,EAAwCiI,SAAxC,EAAmD;AACjD,QAAMrI,MAAM,GAAG,MAAM2H,qBAAqB,CAACvH,EAAD,EAAKiI,SAAL,CAA1C;AACA,SAAOrI,MAAM,CAAC6D,MAAP,CAAc5D,CAAC,IAAI;AACxB,UAAMqI,eAAe,GAAGrI,CAAC,CAACoE,UAAF,CAAavB,GAAb,CAAiB7C,CAAC,IAAIA,CAAC,CAAC0D,WAAF,EAAtB,CAAxB;;AACA,WAAO2E,eAAe,CAACC,QAAhB,CAAyBF,SAAS,CAAC1E,WAAV,EAAzB,CAAP;AACD,GAHM,EAGJ,CAHI,KAGE,IAHT;AAID;;AAED,eAAe6E,iBAAf,CAAkCpI,EAAlC,EAAsCF,OAAtC,EAA+C;AAC7C,SAAOqC,SAAS,CAACnC,EAAD,EAAKnC,WAAL,EAAkBa,aAAlB,EAAiC,CAAC+H,UAAD,EAAanE,EAAb,KAC/C2C,MAAM,CAACwB,UAAD,EAAa3G,OAAb,EAAsByB,MAAM,IAAI;AACpC,QAAIA,MAAJ,EAAY;AACV,aAAOe,EAAE,CAACf,MAAD,CAAT;AACD;;AACD0D,IAAAA,MAAM,CAACwB,UAAU,CAACa,KAAX,CAAiB1I,kBAAjB,CAAD,EAAuCkB,OAAvC,EAAgDyB,MAAM,IAAIe,EAAE,CAACf,MAAM,IAAI,IAAX,CAA5D,CAAN;AACD,GALK,CADQ,CAAhB;AAQD;;AAED,SAASyE,GAAT,CAAchG,EAAd,EAAkBoC,SAAlB,EAA6B7C,GAA7B,EAAkC;AAChC,SAAO4C,SAAS,CAACnC,EAAD,EAAKoC,SAAL,EAAgB1D,aAAhB,EAA+B,CAAC2B,KAAD,EAAQiC,EAAR,KAC7C2C,MAAM,CAAC5E,KAAD,EAAQd,GAAR,EAAa+C,EAAb,CADQ,CAAhB;AAGD;;AAED,SAASnD,GAAT,CAAca,EAAd,EAAkBoC,SAAlB,EAA6B7C,GAA7B,EAAkC8I,KAAlC,EAAyC;AACvC,SAAOlG,SAAS,CAACnC,EAAD,EAAKoC,SAAL,EAAgBzD,cAAhB,EAAiC0B,KAAD,IAC9CA,KAAK,CAAC4G,GAAN,CAAUoB,KAAV,EAAiB9I,GAAjB,CADc,CAAhB;AAGD;;AAED,SAAS+I,2BAAT,CAAsCtI,EAAtC,EAA0CF,OAA1C,EAAmD;AACjD,SAAOqC,SAAS,CAACnC,EAAD,EAAKjC,eAAL,EAAsBY,cAAtB,EAAuC0B,KAAD,IAAW;AAC/D4E,IAAAA,MAAM,CAAC5E,KAAD,EAAQP,OAAR,EAAiByB,MAAM,IAC3BlB,KAAK,CAAC4G,GAAN,CAAU,CAAC1F,MAAM,IAAI,CAAX,IAAgB,CAA1B,EAA6BzB,OAA7B,CADI,CAAN;AAGD,GAJe,CAAhB;AAKD;;AAED,SAASyI,mBAAT,CAA8BvI,EAA9B,EAAkCwI,gBAAlC,EAAoDC,KAApD,EAA2D;AACzD,MAAIA,KAAK,KAAK,CAAd,EAAiB;AACf,WAAO,EAAP;AACD;;AACD,SAAOtG,SAAS,CAACnC,EAAD,EAAK,CAACjC,eAAD,EAAkBF,WAAlB,CAAL,EAAqCa,aAArC,EAAoD,CAAC,CAACgK,cAAD,EAAiBjC,UAAjB,CAAD,EAA+BnE,EAA/B,KAAsC;AACxG,UAAMsD,OAAO,GAAG,EAAhB;;AACA8C,IAAAA,cAAc,CAACpB,KAAf,CAAqBnJ,WAArB,EAAkCwK,UAAlC,CAA6ChI,SAA7C,EAAwD,MAAxD,EAAgEW,SAAhE,GAA4EQ,CAAC,IAAI;AAC/E,YAAM8G,MAAM,GAAG9G,CAAC,CAACkD,MAAF,CAASzD,MAAxB;;AACA,UAAI,CAACqH,MAAL,EAAa;AAAE;AACb,eAAOtG,EAAE,CAACsD,OAAD,CAAT;AACD;;AAED,eAASiD,SAAT,CAAoBtH,MAApB,EAA4B;AAC1BqE,QAAAA,OAAO,CAAClG,IAAR,CAAa6B,MAAb;;AACA,YAAIqE,OAAO,CAACpB,MAAR,KAAmBiE,KAAvB,EAA8B;AAC5B,iBAAOnG,EAAE,CAACsD,OAAD,CAAT,CAD4B,CACT;AACpB;;AACDgD,QAAAA,MAAM,CAACE,QAAP;AACD;;AAED,YAAMC,aAAa,GAAGH,MAAM,CAACI,UAA7B;AACA,YAAMC,MAAM,GAAGT,gBAAgB,CAACU,MAAjB,CAAwBH,aAAxB,CAAf;;AACA,UAAIE,MAAJ,EAAY;AACV,eAAOJ,SAAS,CAACI,MAAD,CAAhB;AACD,OAlB8E,CAmB/E;;;AACAhE,MAAAA,MAAM,CAACwB,UAAD,EAAasC,aAAb,EAA4B3E,KAAK,IAAI;AACzC,YAAIA,KAAJ,EAAW;AACT,iBAAOyE,SAAS,CAACzE,KAAD,CAAhB;AACD,SAHwC,CAIzC;;;AACAwE,QAAAA,MAAM,CAACE,QAAP;AACD,OANK,CAAN;AAOD,KA3BD;AA4BD,GA9Be,CAAhB;AA+BD,C,CAED;;;AAEA,SAASK,GAAT,GAAgB,CACf;;AAED,SAASC,IAAT,GAAiB;AACf;AACA;AACEC,IAAAA,OAAO,CAACD,IAAR,CAAa,GAAGE,SAAhB;AACD;AACF,C,CAED;AACA;;;AAEA,MAAMC,WAAW,GAAG,EAApB,C,CAAwB;;AAExB,SAASC,IAAT,CAAevK,GAAf,EAAoBwK,YAApB,EAAkC;AAChC,QAAM/G,GAAG,GAAG,IAAIgH,GAAJ,EAAZ;;AACA,OAAK,MAAMpK,IAAX,IAAmBL,GAAnB,EAAwB;AACtB,UAAMqF,MAAM,GAAGmF,YAAY,CAACnK,IAAD,CAA3B;;AACA,SAAK,MAAMwI,KAAX,IAAoBxD,MAApB,EAA4B;AAC1B,UAAIqF,UAAU,GAAGjH,GAAjB;;AACA,WAAK,IAAI6C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuC,KAAK,CAACtD,MAA1B,EAAkCe,CAAC,EAAnC,EAAuC;AACrC,cAAMqE,IAAI,GAAG9B,KAAK,CAAC+B,MAAN,CAAatE,CAAb,CAAb;AACA,YAAIuE,OAAO,GAAGH,UAAU,CAAC3D,GAAX,CAAe4D,IAAf,CAAd;;AACA,YAAI,CAACE,OAAL,EAAc;AACZA,UAAAA,OAAO,GAAG,IAAIJ,GAAJ,EAAV;AACAC,UAAAA,UAAU,CAACxK,GAAX,CAAeyK,IAAf,EAAqBE,OAArB;AACD;;AACDH,QAAAA,UAAU,GAAGG,OAAb;AACD;;AACD,UAAIC,YAAY,GAAGJ,UAAU,CAAC3D,GAAX,CAAeuD,WAAf,CAAnB;;AACA,UAAI,CAACQ,YAAL,EAAmB;AACjBA,QAAAA,YAAY,GAAG,EAAf;AACAJ,QAAAA,UAAU,CAACxK,GAAX,CAAeoK,WAAf,EAA4BQ,YAA5B;AACD;;AACDA,MAAAA,YAAY,CAACrK,IAAb,CAAkBJ,IAAlB;AACD;AACF;;AAED,QAAM0K,MAAM,GAAG,CAACxC,KAAD,EAAQyC,KAAR,KAAkB;AAC/B,QAAIN,UAAU,GAAGjH,GAAjB;;AACA,SAAK,IAAI6C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiC,KAAK,CAAChD,MAA1B,EAAkCe,CAAC,EAAnC,EAAuC;AACrC,YAAMqE,IAAI,GAAGpC,KAAK,CAACqC,MAAN,CAAatE,CAAb,CAAb;AACA,YAAMuE,OAAO,GAAGH,UAAU,CAAC3D,GAAX,CAAe4D,IAAf,CAAhB;;AACA,UAAIE,OAAJ,EAAa;AACXH,QAAAA,UAAU,GAAGG,OAAb;AACD,OAFD,MAEO;AACL,eAAO,EAAP;AACD;AACF;;AAED,QAAIG,KAAJ,EAAW;AACT,YAAMrE,OAAO,GAAG+D,UAAU,CAAC3D,GAAX,CAAeuD,WAAf,CAAhB;AACA,aAAO3D,OAAO,IAAI,EAAlB;AACD;;AAED,UAAMA,OAAO,GAAG,EAAhB,CAjB+B,CAkB/B;;AACA,UAAMsE,KAAK,GAAGP,UAAU,GAAG,CAACA,UAAD,CAAH,GAAkB,EAA1C;;AACA,WAAOO,KAAK,CAAC1F,MAAb,EAAqB;AACnB,YAAMmF,UAAU,GAAGO,KAAK,CAACC,KAAN,EAAnB;AACA,YAAMC,kBAAkB,GAAG,CAAC,GAAGT,UAAU,CAAClJ,OAAX,EAAJ,EAA0BgE,IAA1B,CAA+B,CAACmD,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAR,GAAc,CAAC,CAAf,GAAmB,CAA5D,CAA3B;;AACA,WAAK,MAAM,CAACtI,GAAD,EAAM8I,KAAN,CAAX,IAA2B+B,kBAA3B,EAA+C;AAC7C,YAAI7K,GAAG,KAAKgK,WAAZ,EAAyB;AAAE;AACzB3D,UAAAA,OAAO,CAAClG,IAAR,CAAa,GAAG2I,KAAhB;AACD,SAFD,MAEO;AACL6B,UAAAA,KAAK,CAACxK,IAAN,CAAW2I,KAAX;AACD;AACF;AACF;;AACD,WAAOzC,OAAP;AACD,GAhCD;;AAkCA,SAAOoE,MAAP;AACD;;AAED,MAAMK,YAAY,GAAG,CACnB,MADmB,EAEnB,YAFmB,EAGnB,KAHmB,CAArB;;AAMA,SAASC,kBAAT,CAA6BC,YAA7B,EAA2C;AACzC,QAAMC,OAAO,GAAGD,YAAY,IAAIE,KAAK,CAACD,OAAN,CAAcD,YAAd,CAAhC;AACA,QAAMG,iBAAiB,GAAGF,OAAO,IAC/BD,YAAY,CAAC/F,MADW,KAEvB,CAAC+F,YAAY,CAAC,CAAD,CAAb,IAAoBF,YAAY,CAACxE,IAAb,CAAkBtG,GAAG,IAAI,EAAEA,GAAG,IAAIgL,YAAY,CAAC,CAAD,CAArB,CAAzB,CAFG,CAA1B;;AAGA,MAAI,CAACC,OAAD,IAAYE,iBAAhB,EAAmC;AACjC,UAAM,IAAIlN,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF;;AAED,SAASgL,gBAAT,CAA2B+B,YAA3B,EAAyC;AACvCD,EAAAA,kBAAkB,CAACC,YAAD,CAAlB;;AAEA,QAAMI,UAAU,GAAG,CAAC/C,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAAC1H,IAAF,CAAOqD,WAAP,KAAuBsE,CAAC,CAAC3H,IAAF,CAAOqD,WAAP,EAAvB,GAA8C,CAAC,CAA/C,GAAmD,CAAhF,CAHuC,CAKvC;AACA;AACA;;;AACA,QAAM+C,GAAG,GAAGiE,YAAY,CAAC9F,IAAb,CAAkBkG,UAAlB,CAAZ,CARuC,CAUvC;AACA;AACA;;AACA,QAAMC,aAAa,GAAGxG,KAAK,IACzB,CAAC,GAAG,IAAIhF,GAAJ,CAAQgF,KAAK,CAACH,UAAN,CAAiBvB,GAAjB,CAAqBuF,SAAS,IAAI9E,aAAa,CAAC8E,SAAD,CAA/C,EAA4D1D,IAA5D,EAAR,CAAJ,CADF;;AAGA,QAAMsG,UAAU,GAAGrB,IAAI,CAACe,YAAD,EAAeK,aAAf,CAAvB;;AACA,QAAME,kBAAkB,GAAGjL,CAAC,IAAIgL,UAAU,CAAChL,CAAD,EAAI,IAAJ,CAA1C;;AACA,QAAMkL,cAAc,GAAGlL,CAAC,IAAIgL,UAAU,CAAChL,CAAD,EAAI,KAAJ,CAAtC,CAlBuC,CAoBvC;AACA;AACA;;;AACA,QAAMmK,MAAM,GAAGxC,KAAK,IAAI;AACtB,UAAMlD,MAAM,GAAGnB,aAAa,CAACqE,KAAD,CAA5B;AACA,UAAMC,mBAAmB,GAAGnD,MAAM,CAAC5B,GAAP,CAAW,CAACoF,KAAD,EAAQvC,CAAR,KACrC,CAACA,CAAC,GAAGjB,MAAM,CAACE,MAAP,GAAgB,CAApB,GAAwBsG,kBAAxB,GAA6CC,cAA9C,EAA8DjD,KAA9D,CAD0B,CAA5B;AAGA,WAAOtC,iBAAiB,CAACiC,mBAAD,EAAsB5H,CAAC,IAAIA,CAAC,CAACK,IAA7B,CAAjB,CAAoDuE,IAApD,CAAyDkG,UAAzD,CAAP;AACD,GAND,CAvBuC,CA+BvC;AACA;AACA;;;AACA,QAAMK,gBAAgB,GAAG,IAAItB,GAAJ,EAAzB;AACA,QAAMuB,WAAW,GAAG,IAAIvB,GAAJ,EAApB;;AACA,OAAK,MAAMwB,WAAX,IAA0BX,YAA1B,EAAwC;AACtCU,IAAAA,WAAW,CAAC9L,GAAZ,CAAgB+L,WAAW,CAAChL,IAAZ,CAAiBqD,WAAjB,EAAhB,EAAgD2H,WAAhD;;AACA,SAAK,MAAMjD,SAAX,IAAwBiD,WAAW,CAACjH,UAApC,EAAgD;AAC9C+G,MAAAA,gBAAgB,CAAC7L,GAAjB,CAAqB8I,SAAS,CAAC1E,WAAV,EAArB,EAA8C2H,WAA9C;AACD;AACF;;AAED,QAAMC,WAAW,GAAGlD,SAAS,IAAI+C,gBAAgB,CAAChF,GAAjB,CAAqBiC,SAAS,CAAC1E,WAAV,EAArB,CAAjC;;AACA,QAAM2F,MAAM,GAAGhJ,IAAI,IAAI+K,WAAW,CAACjF,GAAZ,CAAgB9F,IAAI,CAACqD,WAAL,EAAhB,CAAvB;;AAEA,SAAO;AACL+C,IAAAA,GADK;AAEL0D,IAAAA,MAFK;AAGLmB,IAAAA,WAHK;AAILjC,IAAAA;AAJK,GAAP;AAMD,C,CAED;AACA;;;AACA,SAASkC,UAAT,CAAqBhH,KAArB,EAA4B;AAC1B,MAAI,CAACA,KAAL,EAAY;AACV,WAAOA,KAAP;AACD;;AACD,SAAOA,KAAK,CAACE,MAAb;;AACA,MAAIF,KAAK,CAACM,SAAV,EAAqB;AACnB,UAAM2G,GAAG,GAAGjH,KAAK,CAACM,SAAN,CAAgBF,MAA5B;AACAJ,IAAAA,KAAK,CAACF,KAAN,GAAcuG,KAAK,CAACY,GAAD,CAAnB;;AACA,SAAK,IAAI9F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8F,GAApB,EAAyB9F,CAAC,EAA1B,EAA8B;AAC5BnB,MAAAA,KAAK,CAACF,KAAN,CAAYqB,CAAZ,IAAiB;AACfV,QAAAA,IAAI,EAAET,KAAK,CAACM,SAAN,CAAgBa,CAAhB,CADS;AAEfzF,QAAAA,OAAO,EAAEsE,KAAK,CAACO,YAAN,CAAmBY,CAAnB,CAFM;AAGflB,QAAAA,OAAO,EAAED,KAAK,CAACQ,YAAN,CAAmBW,CAAnB;AAHM,OAAjB;AAKD;;AACD,WAAOnB,KAAK,CAACM,SAAb;AACA,WAAON,KAAK,CAACO,YAAb;AACA,WAAOP,KAAK,CAACQ,YAAb;AACD;;AACD,SAAOR,KAAP;AACD;;AAED,SAASkH,QAAT,CAAmBnF,IAAnB,EAAyB;AACvB,MAAI,CAACA,IAAL,EAAW;AACTiD,IAAAA,IAAI,CAAC,yFAAD,CAAJ;AACD;AACF;;AAED,MAAMmC,cAAc,GAAG,CACrB,YADqB,EAErB,OAFqB,EAGrB,UAHqB,EAIrB,OAJqB,EAKrB,OALqB,EAMrB,YANqB,EAOrB,MAPqB,EAQrB,SARqB,CAAvB;;AAWA,SAASC,mBAAT,CAA8B5H,aAA9B,EAA6C;AAC3C,MAAI,CAACA,aAAD,IACF,CAAC6G,KAAK,CAACD,OAAN,CAAc5G,aAAd,CADC,IAEF,CAACA,aAAa,CAAC,CAAD,CAFZ,IAGD,OAAOA,aAAa,CAAC,CAAD,CAApB,KAA4B,QAH3B,IAIF2H,cAAc,CAAC1F,IAAf,CAAoBtG,GAAG,IAAK,EAAEA,GAAG,IAAIqE,aAAa,CAAC,CAAD,CAAtB,CAA5B,CAJF,EAI4D;AAC1D,UAAM,IAAIpG,KAAJ,CAAU,yEAAV,CAAN;AACD;AACF;;AAED,SAASiO,YAAT,CAAuBC,QAAvB,EAAiCC,UAAjC,EAA6C;AAC3C,MAAIC,IAAI,CAACC,KAAL,CAAWH,QAAQ,CAACI,MAAT,GAAkB,GAA7B,MAAsC,CAA1C,EAA6C;AAC3C,UAAM,IAAItO,KAAJ,CAAU,sBAAsBmO,UAAtB,GAAmC,KAAnC,GAA2CD,QAAQ,CAACI,MAA9D,CAAN;AACD;AACF;;AAED,eAAeC,OAAf,CAAwBJ,UAAxB,EAAoC;AAClC,QAAMD,QAAQ,GAAG,MAAMM,KAAK,CAACL,UAAD,EAAa;AAAE5G,IAAAA,MAAM,EAAE;AAAV,GAAb,CAA5B;AACA0G,EAAAA,YAAY,CAACC,QAAD,EAAWC,UAAX,CAAZ;AACA,QAAMxF,IAAI,GAAGuF,QAAQ,CAACO,OAAT,CAAiBjG,GAAjB,CAAqB,MAArB,CAAb;AACAsF,EAAAA,QAAQ,CAACnF,IAAD,CAAR;AACA,SAAOA,IAAP;AACD;;AAED,eAAe+F,cAAf,CAA+BP,UAA/B,EAA2C;AACzC,QAAMD,QAAQ,GAAG,MAAMM,KAAK,CAACL,UAAD,CAA5B;AACAF,EAAAA,YAAY,CAACC,QAAD,EAAWC,UAAX,CAAZ;AACA,QAAMxF,IAAI,GAAGuF,QAAQ,CAACO,OAAT,CAAiBjG,GAAjB,CAAqB,MAArB,CAAb;AACAsF,EAAAA,QAAQ,CAACnF,IAAD,CAAR;AACA,QAAMvC,aAAa,GAAG,MAAM8H,QAAQ,CAACS,IAAT,EAA5B;AACAX,EAAAA,mBAAmB,CAAC5H,aAAD,CAAnB;AACA,SAAO,CAACuC,IAAD,EAAOvC,aAAP,CAAP;AACD,C,CAED;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASwI,yBAAT,CAAmCC,MAAnC,EAA2C;AACvC,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,KAAK,GAAG,IAAIC,UAAJ,CAAeH,MAAf,CAAZ;AACA,MAAI7H,MAAM,GAAG+H,KAAK,CAACE,UAAnB;AACA,MAAIlH,CAAC,GAAG,CAAC,CAAT;;AACA,SAAO,EAAEA,CAAF,GAAMf,MAAb,EAAqB;AACjB8H,IAAAA,MAAM,IAAII,MAAM,CAACC,YAAP,CAAoBJ,KAAK,CAAChH,CAAD,CAAzB,CAAV;AACH;;AACD,SAAO+G,MAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,yBAAT,CAAmCN,MAAnC,EAA2C;AACvC,MAAI9H,MAAM,GAAG8H,MAAM,CAAC9H,MAApB;AACA,MAAIqI,GAAG,GAAG,IAAIC,WAAJ,CAAgBtI,MAAhB,CAAV;AACA,MAAIvF,GAAG,GAAG,IAAIuN,UAAJ,CAAeK,GAAf,CAAV;AACA,MAAItH,CAAC,GAAG,CAAC,CAAT;;AACA,SAAO,EAAEA,CAAF,GAAMf,MAAb,EAAqB;AACjBvF,IAAAA,GAAG,CAACsG,CAAD,CAAH,GAAS+G,MAAM,CAACS,UAAP,CAAkBxH,CAAlB,CAAT;AACH;;AACD,SAAOsH,GAAP;AACH,C,CAED;;;AACA,eAAeG,YAAf,CAA6BC,MAA7B,EAAqC;AACnC,QAAMC,QAAQ,GAAGC,IAAI,CAACC,SAAL,CAAeH,MAAf,CAAjB;AACA,QAAMI,QAAQ,GAAGT,yBAAyB,CAACM,QAAD,CAA1C,CAFmC,CAGnC;;AACA,QAAMI,SAAS,GAAG,MAAMC,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqB,OAArB,EAA8BJ,QAA9B,CAAxB;AACA,QAAMK,YAAY,GAAGtB,yBAAyB,CAACkB,SAAD,CAA9C;AACA,QAAMjO,GAAG,GAAGsO,IAAI,CAACD,YAAD,CAAhB;AACA,SAAOrO,GAAP;AACD;;AAED,eAAeuO,eAAf,CAAgC5N,EAAhC,EAAoC2L,UAApC,EAAgD;AAC9C;AACA,MAAI/H,aAAJ;AACA,MAAIuC,IAAI,GAAG,MAAM4F,OAAO,CAACJ,UAAD,CAAxB;;AACA,MAAI,CAACxF,IAAL,EAAW;AAAE;AACX,UAAM0H,WAAW,GAAG,MAAM3B,cAAc,CAACP,UAAD,CAAxC;AACAxF,IAAAA,IAAI,GAAG0H,WAAW,CAAC,CAAD,CAAlB;AACAjK,IAAAA,aAAa,GAAGiK,WAAW,CAAC,CAAD,CAA3B;;AACA,QAAI,CAAC1H,IAAL,EAAW;AACTA,MAAAA,IAAI,GAAG,MAAM6G,YAAY,CAACpJ,aAAD,CAAzB;AACD;AACF;;AACD,MAAI,MAAMqC,OAAO,CAACjG,EAAD,EAAK2L,UAAL,EAAiBxF,IAAjB,CAAjB,EAAyC,CAAzC,KAAgD;AAC9C,QAAI,CAACvC,aAAL,EAAoB;AAClB,YAAMiK,WAAW,GAAG,MAAM3B,cAAc,CAACP,UAAD,CAAxC;AACA/H,MAAAA,aAAa,GAAGiK,WAAW,CAAC,CAAD,CAA3B;AACD;;AACD,UAAMtH,QAAQ,CAACvG,EAAD,EAAK4D,aAAL,EAAoB+H,UAApB,EAAgCxF,IAAhC,CAAd;AACD;AACF;;AAED,eAAe2H,oBAAf,CAAqC9N,EAArC,EAAyC2L,UAAzC,EAAqD;AACnD,MAAI,CAACxF,IAAD,EAAOvC,aAAP,IAAwB,MAAMsI,cAAc,CAACP,UAAD,CAAhD;;AACA,MAAI,CAACxF,IAAL,EAAW;AACT;AACA;AACAA,IAAAA,IAAI,GAAG,MAAM6G,YAAY,CAACpJ,aAAD,CAAzB;AACD;;AAED,QAAM2C,QAAQ,CAACvG,EAAD,EAAK4D,aAAL,EAAoB+H,UAApB,EAAgCxF,IAAhC,CAAd;AACD;;AAED,MAAM4H,QAAN,CAAe;AACbC,EAAAA,WAAW,CAAE;AAAErC,IAAAA,UAAU,GAAG7M,mBAAf;AAAoCmP,IAAAA,MAAM,GAAGlP,cAA7C;AAA6DmM,IAAAA,WAAW,GAAG;AAA3E,MAAkF,EAApF,EAAwF;AACjG,SAAKS,UAAL,GAAkBA,UAAlB;AACA,SAAKsC,MAAL,GAAcA,MAAd;AACA,SAAKC,OAAL,GAAgB,wBAAuB,KAAKD,MAAO,EAAnD;AACA,SAAKE,GAAL,GAAWxN,SAAX;AACA,SAAKyN,WAAL,GAAmBzN,SAAnB;AACA,SAAK0N,OAAL,GAAe7F,gBAAgB,CAAC0C,WAAD,CAA/B;AAEA,SAAKoD,MAAL,GAAc,KAAKA,MAAL,CAAYC,IAAZ,CAAiB,IAAjB,CAAd;AACA,SAAKC,MAAL,GAAc,KAAKC,KAAL,EAAd;AACD;;AAED,QAAMA,KAAN,GAAe;AACb,UAAMzO,EAAE,GAAG,KAAKmO,GAAL,GAAW,MAAMjM,YAAY,CAAC,KAAKgM,OAAN,CAAxC;AAEAlL,IAAAA,kBAAkB,CAAC,KAAKkL,OAAN,EAAe,KAAKI,MAApB,CAAlB;AACA,UAAM3C,UAAU,GAAG,KAAKA,UAAxB;AACA,UAAM+C,KAAK,GAAG,MAAM3I,OAAO,CAAC/F,EAAD,CAA3B;;AAEA,QAAI0O,KAAJ,EAAW;AACT,YAAMZ,oBAAoB,CAAC9N,EAAD,EAAK2L,UAAL,CAA1B;AACD,KAFD,MAEO;AAAE;AACP,WAAKyC,WAAL,GAAmBR,eAAe,CAAC5N,EAAD,EAAK2L,UAAL,CAAlC;AACD;AACF;;AAED,QAAMgD,KAAN,GAAe;AACb,QAAI,CAAC,KAAKH,MAAV,EAAkB;AAChB,WAAKA,MAAL,GAAc,KAAKC,KAAL,EAAd;AACD;;AACD,WAAO,KAAKD,MAAZ;AACD;;AAED,QAAMtH,eAAN,CAAuBnD,KAAvB,EAA8B;AAC5BtG,IAAAA,YAAY,CAACsG,KAAD,CAAZ;AACA,UAAM,KAAK4K,KAAL,EAAN;AACA,WAAOhP,SAAS,CAAC,MAAMuH,eAAe,CAAC,KAAKiH,GAAN,EAAWpK,KAAX,CAAtB,CAAT,CAAkDrB,GAAlD,CAAsD0I,UAAtD,CAAP;AACD;;AAED,QAAM7D,qBAAN,CAA6BC,KAA7B,EAAoC;AAClClK,IAAAA,oBAAoB,CAACkK,KAAD,CAApB;AACA,UAAM,KAAKmH,KAAL,EAAN;;AACA,UAAMC,OAAO,GAAG,KAAKP,OAAL,CAAarE,MAAb,CAAoBxC,KAApB,CAAhB;;AACA,UAAMqH,OAAO,GAAGlP,SAAS,CAAC,MAAM4H,qBAAqB,CAAC,KAAK4G,GAAN,EAAW3G,KAAX,CAA5B,CAAT,CAAwD9E,GAAxD,CAA4D0I,UAA5D,CAAhB;AACA,WAAO,CACL,GAAGwD,OADE,EAEL,GAAGC,OAFE,CAAP;AAID;;AAED,QAAM7G,mBAAN,CAA2BC,SAA3B,EAAsC;AACpC3K,IAAAA,oBAAoB,CAAC2K,SAAD,CAApB;AACA,UAAM,KAAK0G,KAAL,EAAN;;AACA,UAAM1F,MAAM,GAAG,KAAKoF,OAAL,CAAalD,WAAb,CAAyBlD,SAAzB,CAAf;;AACA,QAAIgB,MAAJ,EAAY;AACV,aAAOA,MAAP;AACD;;AACD,WAAOmC,UAAU,CAAC,MAAMpD,mBAAmB,CAAC,KAAKmG,GAAN,EAAWlG,SAAX,CAA1B,CAAjB;AACD;;AAED,QAAM6G,uBAAN,CAA+B/F,aAA/B,EAA8C;AAC5CzL,IAAAA,oBAAoB,CAACyL,aAAD,CAApB;AACA,UAAM,KAAK4F,KAAL,EAAN;;AACA,UAAM1F,MAAM,GAAG,KAAKoF,OAAL,CAAanF,MAAb,CAAoBH,aAApB,CAAf;;AACA,QAAIE,MAAJ,EAAY;AACV,aAAOA,MAAP;AACD;;AACD,WAAOmC,UAAU,CAAC,MAAMhD,iBAAiB,CAAC,KAAK+F,GAAN,EAAWpF,aAAX,CAAxB,CAAjB;AACD;;AAED,QAAMgG,oBAAN,GAA8B;AAC5B,UAAM,KAAKJ,KAAL,EAAN;AACA,WAAO,CAAC,MAAM3I,GAAG,CAAC,KAAKmI,GAAN,EAAWrQ,cAAX,EAA2BW,sBAA3B,CAAV,KAAiE,CAAxE;AACD;;AAED,QAAMuQ,oBAAN,CAA4BC,QAA5B,EAAsC;AACpCxR,IAAAA,YAAY,CAACwR,QAAD,CAAZ;AACA,UAAM,KAAKN,KAAL,EAAN;AACA,WAAOxP,GAAG,CAAC,KAAKgP,GAAN,EAAWrQ,cAAX,EAA2BW,sBAA3B,EAAmDwQ,QAAnD,CAAV;AACD;;AAED,QAAM3G,2BAAN,CAAmCS,aAAnC,EAAkD;AAChDzL,IAAAA,oBAAoB,CAACyL,aAAD,CAApB;AACA,UAAM,KAAK4F,KAAL,EAAN;AACA,WAAOrG,2BAA2B,CAAC,KAAK6F,GAAN,EAAWpF,aAAX,CAAlC;AACD;;AAED,QAAMR,mBAAN,CAA2BE,KAA3B,EAAkC;AAChChL,IAAAA,YAAY,CAACgL,KAAD,CAAZ;AACA,UAAM,KAAKkG,KAAL,EAAN;AACA,WAAO,CAAC,MAAMpG,mBAAmB,CAAC,KAAK4F,GAAN,EAAW,KAAKE,OAAhB,EAAyB5F,KAAzB,CAA1B,EAA2D/F,GAA3D,CAA+D0I,UAA/D,CAAP;AACD;;AAED,MAAIF,WAAJ,CAAiBX,YAAjB,EAA+B;AAC7B,SAAK8D,OAAL,GAAe7F,gBAAgB,CAAC+B,YAAD,CAA/B;AACD;;AAED,MAAIW,WAAJ,GAAmB;AACjB,WAAO,KAAKmD,OAAL,CAAa/H,GAApB;AACD;;AAED,QAAM4I,SAAN,GAAmB;AACjB,UAAM,KAAKP,KAAL,EAAN,CADiB,CACG;;AACpB,QAAI;AACF,YAAM,KAAKP,WAAX,CADE,CACsB;AACzB,KAFD,CAEE,OAAOe,GAAP,EAAY;AAAE;AAA6C;;AAC7D,QAAI,KAAKhB,GAAT,EAAc;AACZ,aAAO,IAAP,CADY,CACA;AACb;AACF,GA9GY,CAgHb;;;AACAG,EAAAA,MAAM,GAAI;AACRnF,IAAAA,GAAG,CAAC,iBAAD,EAAoB,KAAK+E,OAAzB,CAAH,CADQ,CAER;AACA;AACA;AACA;;AACA,SAAKC,GAAL,GAAW,KAAKK,MAAL,GAAc,KAAKJ,WAAL,GAAmBzN,SAA5C;AACD;;AAED,QAAMiC,KAAN,GAAe;AACb,QAAI,MAAM,KAAKsM,SAAL,EAAV,EAA4B;AAC1B,YAAMjN,aAAa,CAAC,KAAKiM,OAAN,CAAnB;AACD;AACF;;AAED,QAAMnH,MAAN,GAAgB;AACd,QAAI,MAAM,KAAKmI,SAAL,EAAV,EAA4B;AAC1B,YAAMnM,cAAc,CAAC,KAAKmL,OAAN,CAApB;AACD;AACF;;AApIY;;AAuIf,eAAeH,QAAf","sourcesContent":["function assertNonEmptyString (str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str)\n  }\n}\n\nfunction assertNumber (number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number)\n  }\n}\n\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\n\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emojibase-data@5/en/data.json';\nconst DEFAULT_LOCALE = 'en';\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy (arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res\n}\n\nfunction uniqEmoji (emojis) {\n  return uniqBy(emojis, _ => _.unicode)\n}\n\nfunction initialMigration (db) {\n  function createObjectStore (name, keyPath, indexes) {\n    const store = keyPath\n      ? db.createObjectStore(name, { keyPath })\n      : db.createObjectStore(name);\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, { multiEntry });\n      }\n    }\n    return store\n  }\n\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI, /* keyPath */ FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS, /* multiEntry */ true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, /* multiEntry */ true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\n\nconst openReqs = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\n\nfunction handleOpenOrDeleteReq (resolve, reject, req) {\n  req.onerror = () => reject(req.error);\n  req.onblocked = () => reject(new Error('IDB blocked'));\n  req.onsuccess = () => resolve(req.result);\n}\n\nasync function createDatabase (dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openReqs[dbName] = req;\n    req.onupgradeneeded = e => {\n      const db = req.result;\n\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(db);\n      }\n    };\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n  // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n  db.onclose = () => closeDatabase(dbName);\n  return db\n}\n\nfunction openDatabase (dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n  return databaseCache[dbName]\n}\n\nfunction dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(storeName, readOnlyOrReadWrite);\n    const store = typeof storeName === 'string'\n      ? tx.objectStore(storeName)\n      : storeName.map(name => tx.objectStore(name));\n    let res;\n    cb(store, (result) => {\n      res = result;\n    });\n\n    tx.oncomplete = () => resolve(res);\n    tx.onerror = () => reject(tx.error);\n  })\n}\n\nfunction closeDatabase (dbName) {\n  // close any open requests\n  const req = openReqs[dbName];\n  const db = req && req.result;\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n  delete openReqs[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\n\nfunction deleteDatabase (dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  })\n}\n\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction addOnCloseListener (dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n  listeners.push(listener);\n}\n\nconst MIN_SEARCH_TEXT_LENGTH = 2;\n\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emojibase-data/en/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst irregularEmoticons = new Set([\n  ':D', 'xD', \":'D\", 'o:)',\n  ':x', ':p', ';p', 'xp',\n  ':l', ':z', ':j', '8D',\n  'xo', '8)', ':B', ':o',\n  ':s', \":'o\", 'Dx', 'x(',\n  'D:', ':c', '>0)', ':3',\n  '</3', '<3', '\\\\m/', ':E',\n  '8#'\n]);\n\nfunction extractTokens (str) {\n  return str\n    .split(/[\\s_]+/)\n    .map(word => {\n      if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n        // for pure emoticons like :) or :-), just leave them as-is\n        return word.toLowerCase()\n      }\n\n      return word\n        .replace(/[)(:,]/g, '')\n        .replace(/â€™/g, \"'\")\n        .toLowerCase()\n    }).filter(Boolean)\n}\n\n// Transform emojibase data for storage in IDB\nfunction transformEmojiBaseData (emojiBaseData) {\n  const res = emojiBaseData.map(({ annotation, emoticon, group, order, shortcodes, skins, tags, emoji, version }) => {\n    const tokens = [...new Set(\n      [\n        ...shortcodes.map(extractTokens).flat(),\n        ...tags.map(extractTokens).flat(),\n        ...extractTokens(annotation),\n        emoticon\n      ]\n        .filter(Boolean)\n        .map(_ => _.toLowerCase())\n        .filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH)\n    )].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      shortcodes,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n      for (const { tone, emoji, version } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n    return res\n  });\n  return res\n}\n\n// helper functions that help compress the code better\n\nfunction callStore (store, method, key, cb) {\n  store[method](key).onsuccess = e => (cb && cb(e.target.result));\n}\n\nfunction getIDB (store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\n\nfunction getAllIDB (store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\n\nfunction getAllKeysIDB (store, key, cb) {\n  callStore(store, 'getAllKeys', key, cb);\n}\n\n// like lodash's minBy\nfunction minBy (array, func) {\n  let minItem = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n  return minItem\n}\n\n// return an array of results representing all items that are found in each one of the arrays\n\nfunction findCommonMembers (arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n  return results\n}\n\nasync function isEmpty (db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL))\n}\n\nasync function hasData (db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL]\n    .map(key => get(db, STORE_KEYVALUE, key)));\n  return (oldETag === eTag && oldUrl === url)\n}\n\nasync function loadData (db, emojiBaseData, url, eTag) {\n  try {\n    const transformedData = transformEmojiBaseData(emojiBaseData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore]) => {\n      let oldETag;\n      let oldUrl;\n      let oldKeys;\n      let todo = 0;\n\n      function checkFetched () {\n        if (++todo === 3) {\n          onFetched();\n        }\n      }\n\n      function onFetched () {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return\n        }\n        // delete old data\n        for (const key of oldKeys) {\n          emojiStore.delete(key);\n        }\n        // insert new data\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n      }\n\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n\n      getAllKeysIDB(emojiStore, undefined, result => {\n        oldKeys = result;\n        checkFetched();\n      });\n    });\n  } finally {\n  }\n}\n\nasync function getEmojiByGroup (db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  })\n}\n\nasync function getEmojiBySearchQuery (db, query) {\n  const tokens = extractTokens(query);\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1\n        ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n        : IDBKeyRange.only(token); // treat all other tokens as an exact match\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  })\n}\n\nasync function getEmojiByShortcode (db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n  return emojis.filter(_ => {\n    const lowerShortcodes = _.shortcodes.map(_ => _.toLowerCase());\n    return lowerShortcodes.includes(shortcode.toLowerCase())\n  })[0] || null\n}\n\nasync function getEmojiByUnicode (db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, cb) => (\n    getIDB(emojiStore, unicode, result => {\n      if (result) {\n        return cb(result)\n      }\n      getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n    })\n  ))\n}\n\nfunction get (db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, cb) => (\n    getIDB(store, key, cb)\n  ))\n}\n\nfunction set (db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, (store) => (\n    store.put(value, key)\n  ))\n}\n\nfunction incrementFavoriteEmojiCount (db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store) => {\n    getIDB(store, unicode, result => (\n      store.put((result || 0) + 1, unicode)\n    ));\n  })\n}\n\nfunction getTopFavoriteEmoji (db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return []\n  }\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], cb) => {\n    const results = [];\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n      if (!cursor) { // no more results\n        return cb(results)\n      }\n\n      function addResult (result) {\n        results.push(result);\n        if (results.length === limit) {\n          return cb(results) // done, reached the limit\n        }\n        cursor.continue();\n      }\n\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n      if (custom) {\n        return addResult(custom)\n      }\n      // TODO: this could be optimized by doing the get and the cursor.continue() in parallel\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji)\n        }\n        // emoji not found somehow, ignore (may happen if custom emoji change)\n        cursor.continue();\n      });\n    };\n  })\n}\n\n// @rollup/plugin-strip doesn't strip console.logs properly\n\nfunction log () {\n}\n\nfunction warn () {\n  /* istanbul ignore if */\n  {\n    console.warn(...arguments);\n  }\n}\n\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie (arr, itemToTokens) {\n  const map = new Map();\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n    for (const token of tokens) {\n      let currentMap = map;\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n        currentMap = nextMap;\n      }\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n      valuesAtCoda.push(item);\n    }\n  }\n\n  const search = (query, exact) => {\n    let currentMap = map;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return []\n      }\n    }\n\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || []\n    }\n\n    const results = [];\n    // traverse\n    const queue = currentMap ? [currentMap] : [];\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) { // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n    return results\n  };\n\n  return search\n}\n\nconst requiredKeys = [\n  'name',\n  'shortcodes',\n  'url'\n];\n\nfunction assertCustomEmojis (customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray &&\n    customEmojis.length &&\n    (!customEmojis[0] || requiredKeys.some(key => !(key in customEmojis[0])));\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Expected custom emojis to be in correct format')\n  }\n}\n\nfunction customEmojiIndex (customEmojis) {\n  assertCustomEmojis(customEmojis);\n\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n\n  //\n  // all()\n  //\n  const all = customEmojis.sort(sortByName);\n\n  //\n  // search()\n  //\n  const emojiToTokens = emoji => (\n    [...new Set(emoji.shortcodes.map(shortcode => extractTokens(shortcode)).flat())]\n  );\n  const searchTrie = trie(customEmojis, emojiToTokens);\n  const searchByExactMatch = _ => searchTrie(_, true);\n  const searchByPrefix = _ => searchTrie(_, false);\n\n  // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (\n      (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token)\n    ));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName)\n  };\n\n  //\n  // byShortcode, byName\n  //\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n    for (const shortcode of customEmoji.shortcodes) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  }\n}\n\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction cleanEmoji (emoji) {\n  if (!emoji) {\n    return emoji\n  }\n  delete emoji.tokens;\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n  return emoji\n}\n\nfunction warnETag (eTag) {\n  if (!eTag) {\n    warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\n\nconst requiredKeys$1 = [\n  'annotation',\n  'emoji',\n  'emoticon',\n  'group',\n  'order',\n  'shortcodes',\n  'tags',\n  'version'\n];\n\nfunction assertEmojiBaseData (emojiBaseData) {\n  if (!emojiBaseData ||\n    !Array.isArray(emojiBaseData) ||\n    !emojiBaseData[0] ||\n    (typeof emojiBaseData[0] !== 'object') ||\n    requiredKeys$1.some(key => (!(key in emojiBaseData[0])))) {\n    throw new Error('Expected emojibase full (not compact) data, but data is in wrong format')\n  }\n}\n\nfunction assertStatus (response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status)\n  }\n}\n\nasync function getETag (dataSource) {\n  const response = await fetch(dataSource, { method: 'HEAD' });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag\n}\n\nasync function getETagAndData (dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiBaseData = await response.json();\n  assertEmojiBaseData(emojiBaseData);\n  return [eTag, emojiBaseData]\n}\n\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\nfunction arrayBufferToBinaryString(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var length = bytes.byteLength;\n    var i = -1;\n    while (++i < length) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\nfunction binaryStringToArrayBuffer(binary) {\n    var length = binary.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    var i = -1;\n    while (++i < length) {\n        arr[i] = binary.charCodeAt(i);\n    }\n    return buf;\n}\n\n// generate a checksum based on the stringified JSON\nasync function jsonChecksum (object) {\n  const inString = JSON.stringify(object);\n  const inBuffer = binaryStringToArrayBuffer(inString);\n  // this does not need to be cryptographically secure, SHA-1 is fine\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res\n}\n\nasync function checkForUpdates (db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiBaseData;\n  let eTag = await getETag(dataSource);\n  if (!eTag) { // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiBaseData = eTagAndData[1];\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiBaseData);\n    }\n  }\n  if (await hasData(db, dataSource, eTag)) ; else {\n    if (!emojiBaseData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiBaseData = eTagAndData[1];\n    }\n    await loadData(db, emojiBaseData, dataSource, eTag);\n  }\n}\n\nasync function loadDataForFirstTime (db, dataSource) {\n  let [eTag, emojiBaseData] = await getETagAndData(dataSource);\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiBaseData);\n  }\n\n  await loadData(db, emojiBaseData, dataSource, eTag);\n}\n\nclass Database {\n  constructor ({ dataSource = DEFAULT_DATA_SOURCE, locale = DEFAULT_LOCALE, customEmoji = [] } = {}) {\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = `emoji-picker-element-${this.locale}`;\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n\n  async _init () {\n    const db = this._db = await openDatabase(this._dbName);\n\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else { // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n\n  async ready () {\n    if (!this._ready) {\n      this._ready = this._init();\n    }\n    return this._ready\n  }\n\n  async getEmojiByGroup (group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji)\n  }\n\n  async getEmojiBySearchQuery (query) {\n    assertNonEmptyString(query);\n    await this.ready();\n    const customs = this._custom.search(query);\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [\n      ...customs,\n      ...natives\n    ]\n  }\n\n  async getEmojiByShortcode (shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n    const custom = this._custom.byShortcode(shortcode);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode))\n  }\n\n  async getEmojiByUnicodeOrName (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    const custom = this._custom.byName(unicodeOrName);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName))\n  }\n\n  async getPreferredSkinTone () {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0\n  }\n\n  async setPreferredSkinTone (skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone)\n  }\n\n  async incrementFavoriteEmojiCount (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName)\n  }\n\n  async getTopFavoriteEmoji (limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji)\n  }\n\n  set customEmoji (customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n\n  get customEmoji () {\n    return this._custom.all\n  }\n\n  async _shutdown () {\n    await this.ready(); // reopen if we've already been closed/deleted\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) { /* ignore network errors (offline-first) */ }\n    if (this._db) {\n      return true // we need to actually run the close/delete logic, so we return true\n    }\n  }\n\n  // clear references to IDB, e.g. during a close event\n  _clear () {\n    log('_clear database', this._dbName);\n    // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n\n  async close () {\n    if (await this._shutdown()) {\n      await closeDatabase(this._dbName);\n    }\n  }\n\n  async delete () {\n    if (await this._shutdown()) {\n      await deleteDatabase(this._dbName);\n    }\n  }\n}\n\nexport default Database;\n"]},"metadata":{},"sourceType":"module"}